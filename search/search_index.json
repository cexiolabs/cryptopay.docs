{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CryptoPay CryptoPay offers a crypto processing features like a: Fiat to Crypto exchange Crypto to Fiat exchange Crypto payments (like buying goods)","title":"Overview"},{"location":"#cryptopay","text":"CryptoPay offers a crypto processing features like a: Fiat to Crypto exchange Crypto to Fiat exchange Crypto payments (like buying goods)","title":"CryptoPay"},{"location":"api/","text":"REST API Authentication Generating an API Key Before being able to sign any requests, you must create an API key via the CryptoPay support. Upon creating a key you will have 3 pieces of information which you must remember: Key - Randomly generated and provided by CryptoPay Secret - Randomly generated and provided by CryptoPay Passphrase - Provided by you to further secure your API access. CryptoPay stores the salted hash of your passphrase for verification, but cannot recover the passphrase if you forget it. API Key Permissions You can restrict the functionality of API keys. Before creating the key, you must choose what permissions you would like the key to have. The permissions are: Merchant Allows a key manage your sub-merchants. Order Allows a key to enter orders, as well as retrieve order data. This includes POST /orders and several GET endpoints. View Allows a key read permissions. This includes most of GET endpoints. Please refer to documentation below to see what API key permissions are required for a specific route. Creating a Request All REST requests must contain the following headers: CP-ACCESS-KEY The api key as a string. CP-ACCESS-SIGN The base64-encoded signature (see Signing a Message). CP-ACCESS-TIMESTAMP A timestamp for your request. CP-ACCESS-PASSPHRASE The passphrase you specified when creating the API key. All request bodies should have content type application/json and be valid JSON. Signing a Message The CP-ACCESS-SIGN header is generated by creating a sha256 HMAC using the base64-decoded secret key on the prehash string timestamp + method + requestPath + body (where + represents string concatenation) and base64-encode the output. The timestamp value is the same as the CP-ACCESS-TIMESTAMP header. The body is the request body string or omitted if there is no request body (typically for GET requests). The method should be UPPER CASE like \"GET\", \"POST\", etc. Note Do not forget to base64-decode the alphanumeric secret string (resulting in 64 bytes) before using it as the key for HMAC. Also, base64-encode the digest output before sending in the header. Bash + OpenSSL SECRET = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" #TIMESTAMP=$(date +%s) TIMESTAMP = 1573753848 METHOD = \"POST\" URLPATH = \"/orders\" BODY = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' WHAT = \" ${ TIMESTAMP }${ METHOD }${ URLPATH }${ BODY } \" SECRET_KEY = $( echo -n \" ${ SECRET } \" | base64 --decode | hexdump -v -e '/1 \"%02x\"' ) echo -n \" ${ WHAT } \" | openssl dgst -sha256 -mac HMAC -macopt \"hexkey: $SECRET_KEY \" | xxd -r -p | base64 // VuQ7KUWKDrVAS3Z1Z88X/5tLo6MoHFH2mHHe5H4kLJA = NodeJS const secret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; //const timestamp = Date.now() / 1000; const timestamp = 1573753848 ; const method = \"POST\" ; const urlPath = \"/orders\" ; const body = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' ; const what = timestamp + method + urlPath + body ; const secretKey = Buffer . from ( secret , \"base64\" ); const hmac = require ( \"crypto\" ). createHmac ( \"sha256\" , secretKey ); console . log ( hmac . update ( what ). digest ( \"base64\" )); // VuQ7KUWKDrVAS3Z1Z88X/5tLo6MoHFH2mHHe5H4kLJA= PHP <?php $secret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; #$timestamp = time() $timestamp = 1573753848 ; $method = \"POST\" ; $urlPath = \"/orders\" ; $body = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' ; $what = $timestamp . $method . $urlPath . $body ; $secretKey = base64_decode ( $secret ); print ( base64_encode ( hash_hmac ( \"sha256\" , $what , $secretKey , true ))); # VuQ7KUWKDrVAS3Z1Z88X/5tLo6MoHFH2mHHe5H4kLJA= C# using System ; // TBD Selecting a Timestamp The CP-ACCESS-TIMESTAMP header MUST be number of seconds since Unix Epoch in UTC. Decimal values are allowed. Your timestamp must be within 30 seconds of the api service time or your request will be considered expired and rejected. We recommend using the time endpoint to query for the API server time if you believe there many be time skew between your server and the API servers. Rate limit The API server will return a 429 response (Too Many Requests) if you have spent your allowance completely. TBD: what is limit? Webhooks Webhooks are \"user-defined HTTP callbacks\". When that event occurs, the source app makes an HTTP request to the URI configured for the webhook. The action taken may be anything. Warning Your endpoint should ALWAYS return a valid HTTP response with HTTP status 2XX. If you do not do this then CryptoPay will think the hook failed and retry it. Security CryptoPay provides modern methods to verify that the request is legitimate. Feel free to use any (or all) of that. SSL verification If you specify a CA Certificate, it will be used to verify the SSL certificate of the webhook endpoint. Otherwise the SSL certificate of the webhook endpoint is verified based on an internal list of Certificate Authorities. Secret token If you specify a secret token , it will be sent with the hook request in the X-CP-TOKEN HTTP header. Encrypt event If you specify a encrypt password , event message will be encrypted. Signing event To sign events CryptoPay uses same algorithm as for incoming request, except header CP-ACCESS-PASSPHRASE is omitted. General rules All endpoints return either a JSON object or array. Data is returned in ascending order. Oldest first, newest last. All time and timestamp related fields are in ISO 8601 . For GET endpoints, parameters must be sent as a query string . For POST, PUT, and DELETE endpoints, the parameters are sent in the request body with content type application/json . Methods /v2/time Note This endpoint does not require authentication. GET /v2/time { \"iso\" : \"2019-11-16T10:57:37.209Z\" , \"epoch\" : 1573901857.209 } The epoch field represents decimal seconds since Unix Epoch /v2/merchant Merchant endpoint is available for sub-merchants management. Every request must be signed using the described authentication scheme. List TBD Create TBD Update TBD /v2/order Order endpoint is available for order management. Every request must be signed using the described authentication scheme. Order statuses : * PENDING - Still in progress * ACCEPTED - Successfully completed * REJECTED - Failure Order lifecycle: graph TD PENDING --> PENDING PENDING --> ACCEPTED PENDING --> REJECTED List GET /v2/order Permission: Order Parameters: Agument Type Mandatory Descripton instument STRING NO Instrument name (like: CRYPTO_BUY) fromId STRING NO ID to get orders from INCLUSIVE startDate ISO 8601 NO Date to get orders from INCLUSIVE endDate ISO 8601 NO Date to get orders until EXCLUSIVE status STRING NO Status: PEDING, ACCEPTED or REJECTED limit INT NO Default 500; max 10000. Create POST /v2/order Generic { \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"some info to be stored along the order\" , \"instrument\" : \"<NAME>\" , ...instrument specific fields... } CRYPTO_BUY (amount fait) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_BUY.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Buy some BTC for 150.42$\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" , \"address\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"autoStart\" : false } CRYPTO_BUY (amount crypto) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_BUY.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Buy 0.05142111 BTC for some $\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"0.05142111\" , \"amountCurrency\" : \"BTC\" , \"address\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"autoStart\" : false } CRYPTO_SELL (amount fait) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_SELL.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell some BTC for 150.42$\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" , \"autoStart\" : false } CRYPTO_SELL (amount crypto) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_SELL.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell 0.05142111 BTC for some $\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"0.05142111\" , \"amountCurrency\" : \"BTC\" , \"autoStart\" : false } Note Instrument specific fields are described Fetch QR Code Warning Only for crypto incoming order GET /v2/order/{orderId}/qrcode/{format} Parameters: Agument Type Descripton orderId string Order identifer format enum svg, svguri Response Content-Type: | Format | Content-Type | Descripton | |----------|--------------------|------------------| | svg | image/svg+xml | SVG Image | svguri | text/plain | SVG Image as data uri |","title":"REST API"},{"location":"api/#rest-api","text":"","title":"REST API"},{"location":"api/#authentication","text":"","title":"Authentication"},{"location":"api/#generating-an-api-key","text":"Before being able to sign any requests, you must create an API key via the CryptoPay support. Upon creating a key you will have 3 pieces of information which you must remember: Key - Randomly generated and provided by CryptoPay Secret - Randomly generated and provided by CryptoPay Passphrase - Provided by you to further secure your API access. CryptoPay stores the salted hash of your passphrase for verification, but cannot recover the passphrase if you forget it.","title":"Generating an API Key"},{"location":"api/#api-key-permissions","text":"You can restrict the functionality of API keys. Before creating the key, you must choose what permissions you would like the key to have. The permissions are:","title":"API Key Permissions"},{"location":"api/#merchant","text":"Allows a key manage your sub-merchants.","title":"Merchant"},{"location":"api/#order","text":"Allows a key to enter orders, as well as retrieve order data. This includes POST /orders and several GET endpoints.","title":"Order"},{"location":"api/#view","text":"Allows a key read permissions. This includes most of GET endpoints. Please refer to documentation below to see what API key permissions are required for a specific route.","title":"View"},{"location":"api/#creating-a-request","text":"All REST requests must contain the following headers: CP-ACCESS-KEY The api key as a string. CP-ACCESS-SIGN The base64-encoded signature (see Signing a Message). CP-ACCESS-TIMESTAMP A timestamp for your request. CP-ACCESS-PASSPHRASE The passphrase you specified when creating the API key. All request bodies should have content type application/json and be valid JSON.","title":"Creating a Request"},{"location":"api/#signing-a-message","text":"The CP-ACCESS-SIGN header is generated by creating a sha256 HMAC using the base64-decoded secret key on the prehash string timestamp + method + requestPath + body (where + represents string concatenation) and base64-encode the output. The timestamp value is the same as the CP-ACCESS-TIMESTAMP header. The body is the request body string or omitted if there is no request body (typically for GET requests). The method should be UPPER CASE like \"GET\", \"POST\", etc. Note Do not forget to base64-decode the alphanumeric secret string (resulting in 64 bytes) before using it as the key for HMAC. Also, base64-encode the digest output before sending in the header. Bash + OpenSSL SECRET = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" #TIMESTAMP=$(date +%s) TIMESTAMP = 1573753848 METHOD = \"POST\" URLPATH = \"/orders\" BODY = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' WHAT = \" ${ TIMESTAMP }${ METHOD }${ URLPATH }${ BODY } \" SECRET_KEY = $( echo -n \" ${ SECRET } \" | base64 --decode | hexdump -v -e '/1 \"%02x\"' ) echo -n \" ${ WHAT } \" | openssl dgst -sha256 -mac HMAC -macopt \"hexkey: $SECRET_KEY \" | xxd -r -p | base64 // VuQ7KUWKDrVAS3Z1Z88X/5tLo6MoHFH2mHHe5H4kLJA = NodeJS const secret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; //const timestamp = Date.now() / 1000; const timestamp = 1573753848 ; const method = \"POST\" ; const urlPath = \"/orders\" ; const body = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' ; const what = timestamp + method + urlPath + body ; const secretKey = Buffer . from ( secret , \"base64\" ); const hmac = require ( \"crypto\" ). createHmac ( \"sha256\" , secretKey ); console . log ( hmac . update ( what ). digest ( \"base64\" )); // VuQ7KUWKDrVAS3Z1Z88X/5tLo6MoHFH2mHHe5H4kLJA= PHP <?php $secret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; #$timestamp = time() $timestamp = 1573753848 ; $method = \"POST\" ; $urlPath = \"/orders\" ; $body = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' ; $what = $timestamp . $method . $urlPath . $body ; $secretKey = base64_decode ( $secret ); print ( base64_encode ( hash_hmac ( \"sha256\" , $what , $secretKey , true ))); # VuQ7KUWKDrVAS3Z1Z88X/5tLo6MoHFH2mHHe5H4kLJA= C# using System ; // TBD","title":"Signing a Message"},{"location":"api/#selecting-a-timestamp","text":"The CP-ACCESS-TIMESTAMP header MUST be number of seconds since Unix Epoch in UTC. Decimal values are allowed. Your timestamp must be within 30 seconds of the api service time or your request will be considered expired and rejected. We recommend using the time endpoint to query for the API server time if you believe there many be time skew between your server and the API servers.","title":"Selecting a Timestamp"},{"location":"api/#rate-limit","text":"The API server will return a 429 response (Too Many Requests) if you have spent your allowance completely. TBD: what is limit?","title":"Rate limit"},{"location":"api/#webhooks","text":"Webhooks are \"user-defined HTTP callbacks\". When that event occurs, the source app makes an HTTP request to the URI configured for the webhook. The action taken may be anything. Warning Your endpoint should ALWAYS return a valid HTTP response with HTTP status 2XX. If you do not do this then CryptoPay will think the hook failed and retry it.","title":"Webhooks"},{"location":"api/#security","text":"CryptoPay provides modern methods to verify that the request is legitimate. Feel free to use any (or all) of that.","title":"Security"},{"location":"api/#ssl-verification","text":"If you specify a CA Certificate, it will be used to verify the SSL certificate of the webhook endpoint. Otherwise the SSL certificate of the webhook endpoint is verified based on an internal list of Certificate Authorities.","title":"SSL verification"},{"location":"api/#secret-token","text":"If you specify a secret token , it will be sent with the hook request in the X-CP-TOKEN HTTP header.","title":"Secret token"},{"location":"api/#encrypt-event","text":"If you specify a encrypt password , event message will be encrypted.","title":"Encrypt event"},{"location":"api/#signing-event","text":"To sign events CryptoPay uses same algorithm as for incoming request, except header CP-ACCESS-PASSPHRASE is omitted.","title":"Signing event"},{"location":"api/#general-rules","text":"All endpoints return either a JSON object or array. Data is returned in ascending order. Oldest first, newest last. All time and timestamp related fields are in ISO 8601 . For GET endpoints, parameters must be sent as a query string . For POST, PUT, and DELETE endpoints, the parameters are sent in the request body with content type application/json .","title":"General rules"},{"location":"api/#methods","text":"","title":"Methods"},{"location":"api/#v2time","text":"Note This endpoint does not require authentication. GET /v2/time { \"iso\" : \"2019-11-16T10:57:37.209Z\" , \"epoch\" : 1573901857.209 } The epoch field represents decimal seconds since Unix Epoch","title":"/v2/time"},{"location":"api/#v2merchant","text":"Merchant endpoint is available for sub-merchants management. Every request must be signed using the described authentication scheme.","title":"/v2/merchant"},{"location":"api/#list","text":"TBD","title":"List"},{"location":"api/#create","text":"TBD","title":"Create"},{"location":"api/#update","text":"TBD","title":"Update"},{"location":"api/#v2order","text":"Order endpoint is available for order management. Every request must be signed using the described authentication scheme. Order statuses : * PENDING - Still in progress * ACCEPTED - Successfully completed * REJECTED - Failure Order lifecycle: graph TD PENDING --> PENDING PENDING --> ACCEPTED PENDING --> REJECTED","title":"/v2/order"},{"location":"api/#list_1","text":"GET /v2/order Permission: Order Parameters: Agument Type Mandatory Descripton instument STRING NO Instrument name (like: CRYPTO_BUY) fromId STRING NO ID to get orders from INCLUSIVE startDate ISO 8601 NO Date to get orders from INCLUSIVE endDate ISO 8601 NO Date to get orders until EXCLUSIVE status STRING NO Status: PEDING, ACCEPTED or REJECTED limit INT NO Default 500; max 10000.","title":"List"},{"location":"api/#create_1","text":"POST /v2/order Generic { \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"some info to be stored along the order\" , \"instrument\" : \"<NAME>\" , ...instrument specific fields... } CRYPTO_BUY (amount fait) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_BUY.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Buy some BTC for 150.42$\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" , \"address\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"autoStart\" : false } CRYPTO_BUY (amount crypto) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_BUY.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Buy 0.05142111 BTC for some $\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"0.05142111\" , \"amountCurrency\" : \"BTC\" , \"address\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"autoStart\" : false } CRYPTO_SELL (amount fait) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_SELL.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell some BTC for 150.42$\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" , \"autoStart\" : false } CRYPTO_SELL (amount crypto) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_SELL.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell 0.05142111 BTC for some $\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"0.05142111\" , \"amountCurrency\" : \"BTC\" , \"autoStart\" : false } Note Instrument specific fields are described","title":"Create"},{"location":"api/#fetch","text":"","title":"Fetch"},{"location":"api/#qr-code","text":"Warning Only for crypto incoming order GET /v2/order/{orderId}/qrcode/{format} Parameters: Agument Type Descripton orderId string Order identifer format enum svg, svguri Response Content-Type: | Format | Content-Type | Descripton | |----------|--------------------|------------------| | svg | image/svg+xml | SVG Image | svguri | text/plain | SVG Image as data uri |","title":"QR Code"},{"location":"release-notes/","text":"Release Notes TBD","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"TBD","title":"Release Notes"},{"location":"terminology/","text":"Terminology Instrument CryptoPay's Instrument defines kind of service. An instrument decribes how to process an order. Different instrument has own set of attributes according kind field. Note Instrument defines applied commissions (may be overriden on in merchant's configuration) Each merchant has own set of allowed instument Instrument kinds Kind Description CRYPTO_BUY Buy crypo asset (convert fiat to crypto) CRYPTO_SELL Sell crypo asset (convert crypto to fiat) CRYPTO_PAYMENT Payment for goods (buy goods by crypto)","title":"Terminology"},{"location":"terminology/#terminology","text":"","title":"Terminology"},{"location":"terminology/#instrument","text":"CryptoPay's Instrument defines kind of service. An instrument decribes how to process an order. Different instrument has own set of attributes according kind field. Note Instrument defines applied commissions (may be overriden on in merchant's configuration) Each merchant has own set of allowed instument","title":"Instrument"},{"location":"terminology/#instrument-kinds","text":"Kind Description CRYPTO_BUY Buy crypo asset (convert fiat to crypto) CRYPTO_SELL Sell crypo asset (convert crypto to fiat) CRYPTO_PAYMENT Payment for goods (buy goods by crypto)","title":"Instrument kinds"},{"location":"websocket-api/","text":"WebSocket API Overview TBD TBD TBD TBD TBD TBD","title":"WebSocket API"},{"location":"websocket-api/#websocket-api","text":"","title":"WebSocket API"},{"location":"websocket-api/#overview","text":"TBD","title":"Overview"},{"location":"websocket-api/#tbd","text":"","title":"TBD"},{"location":"websocket-api/#tbd_1","text":"","title":"TBD"},{"location":"websocket-api/#tbd_2","text":"","title":"TBD"},{"location":"websocket-api/#tbd_3","text":"TBD","title":"TBD"}]}