{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CryptoPay CryptoPay offers a crypto processing features like a: Fiat to Crypto exchange Crypto to Fiat exchange Crypto payments (like buying goods)","title":"Overview"},{"location":"#cryptopay","text":"CryptoPay offers a crypto processing features like a: Fiat to Crypto exchange Crypto to Fiat exchange Crypto payments (like buying goods)","title":"CryptoPay"},{"location":"api/","text":"REST API Authentication Generating an API Key Before being able to sign any requests, you must create an API key via the CryptoPay support. Upon creating a key you will have 3 pieces of information which you must remember: Key - Randomly generated and provided by CryptoPay Secret - Randomly generated and provided by CryptoPay Passphrase - Provided by you to further secure your API access. CryptoPay stores the salted hash of your passphrase for verification, but cannot recover the passphrase if you forget it. API Key Permissions You can restrict the functionality of API keys. Before creating the key, you must choose what permissions you would like the key to have. The permissions are: Merchant permission Allows a key manage your sub-merchants. Order permission Allows a key to enter orders, as well as retrieve order data. This includes POST /order and several GET endpoints. View permission Allows a key read permissions. This includes most of GET endpoints. Please refer to documentation below to see what API key permissions are required for a specific route. Creating a Request All REST requests must contain the following headers: CP-ACCESS-KEY The api key as a string. CP-ACCESS-SIGN The base64-encoded signature (see Signing a Message). CP-ACCESS-TIMESTAMP A timestamp for your request. CP-ACCESS-PASSPHRASE The passphrase you specified when creating the API key. All request bodies should have content type application/json and be valid JSON. Signing a Message The CP-ACCESS-SIGN header is generated by creating a sha256 HMAC using the base64-decoded secret key on the prehash string timestamp + method + requestPath + body (where + represents string concatenation) and base64-encode the output. The timestamp value is the same as the CP-ACCESS-TIMESTAMP header. The body is the request body string or omitted if there is no request body (typically for GET requests). The method should be UPPER CASE like \"GET\", \"POST\", etc. Note Do not forget to base64-decode the alphanumeric secret string (resulting in 64 bytes) before using it as the key for HMAC. Also, base64-encode the digest output before sending in the header. Bash + OpenSSL SECRET = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" #TIMESTAMP=$(date +%s) TIMESTAMP = 1573753848 METHOD = \"POST\" URLPATH = \"/v2/order\" BODY = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' WHAT = \" ${ TIMESTAMP }${ METHOD }${ URLPATH }${ BODY } \" SECRET_KEY = $( echo -n \" ${ SECRET } \" | base64 --decode | hexdump -v -e '/1 \"%02x\"' ) echo -n \" ${ WHAT } \" | openssl dgst -sha256 -mac HMAC -macopt \"hexkey: $SECRET_KEY \" | xxd -r -p | base64 // Zg0U59GORi1dXCSnRfhFeOG/PKod538ij2AnwMFC5wA = NodeJS const secret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; //const timestamp = Date.now() / 1000; const timestamp = 1573753848 ; const method = \"POST\" ; const urlPath = \"/v2/order\" ; const body = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' ; const what = timestamp + method + urlPath + body ; const secretKey = Buffer . from ( secret , \"base64\" ); const hmac = require ( \"crypto\" ). createHmac ( \"sha256\" , secretKey ); console . log ( hmac . update ( what ). digest ( \"base64\" )); // Zg0U59GORi1dXCSnRfhFeOG/PKod538ij2AnwMFC5wA= PHP <?php $secret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; #$timestamp = time() $timestamp = 1573753848 ; $method = \"POST\" ; $urlPath = \"/v2/order\" ; $body = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' ; $what = $timestamp . $method . $urlPath . $body ; $secretKey = base64_decode ( $secret ); print ( base64_encode ( hash_hmac ( \"sha256\" , $what , $secretKey , true ))); # Zg0U59GORi1dXCSnRfhFeOG/PKod538ij2AnwMFC5wA= Selecting a Timestamp The CP-ACCESS-TIMESTAMP header MUST be number of seconds since Unix Epoch in UTC. Decimal values are allowed. Your timestamp must be within 30 seconds of the api service time or your request will be considered expired and rejected. We recommend using the time endpoint to query for the API server time if you believe there many be time skew between your server and the API servers. Rate limit The API server will return a 429 response (Too Many Requests) if you have spent your allowance completely. TBD: what is limit? General rules All endpoints return either a JSON object or array. Data is returned in ascending order. Oldest first, newest last. All time and timestamp related fields are in ISO 8601 . For GET endpoints, parameters must be sent as a query string . For POST, PUT, and DELETE endpoints, the parameters are sent in the request body with content type application/json . Success request codes: 2XX Client's mistakes: 4XX Server's errors: 5XX /v2/time Note This endpoint does not require authentication. GET /v2/time { \"iso\" : \"2019-11-16T10:57:37.209Z\" , \"epoch\" : 1573901857.209 } The epoch field represents decimal seconds since Unix Epoch /v2/merchant Merchant endpoint is available for sub-merchants management. Every request must be signed using the described authentication scheme. List merchants Returns list of sub-merchants according filter defined by parameters GET /v2/merchant Permission: Merchant or View Parameters: Agument Type Mandatory Descripton status ENUM NO Active, Installing, Blocked Create merchant Register a new merchant POST /v2/merchant Permission: Merchant Request body: { \"TBD\" : \"//\" } Update merchant Update an existing merchant PUT /v2/merchant Permission: Merchant Request body: { \"TBD\" : \"//\" } /v2/instument List available instuments Returns list of instuments GET /v2/instument <-- { \"CRYPTO_BUY\" : { \"breakpoints\" : [ \"NEW\" : { \"description\" : \"Order was created. Ready start processing.\" , \"active\" : false , \"//\" : \"TBD\" } ] }, \"CRYPTO_SELL\" : { \"breakpoints\" : [ \"NEW\" : { \"description\" : \"Order was created. Ready start processing.\" , \"active\" : false , \"//\" : \"TBD\" }, \"EXCHANGE\" : { \"description\" : \"Order's balance enough to make exchange. Ready to exchange.\" , \"active\" : false , \"//\" : \"TBD\" } ] }, \"CRYPTO_SELL_INFINITY\" : { \"//\" : \"TBD\" } } Permission: Order or View /v2/order Order endpoint is available for order management. Every request must be signed using the described authentication scheme. Order statuses: NEW - Order registered and waiting for start processing PENDING - Still in progress ACCEPTED - Successfully completed REJECTED - Failure Order lifecycle: graph TD NEW --> PENDING PENDING --> PENDING PENDING --> ACCEPTED PENDING --> REJECTED List orders Returns list of orders according filter defined by parameters GET /v2/order Permission: Order or View Parameters: Agument Type Mandatory Descripton instument STRING NO Instrument name (like: CRYPTO_BUY) fromId STRING NO ID to get orders from INCLUSIVE startDate ISO 8601 NO Date to get orders from INCLUSIVE endDate ISO 8601 NO Date to get orders until EXCLUSIVE status STRING NO Status: NEW, PENDING, ACCEPTED or REJECTED limit INT NO Default 500; max 1000 Create order Register a new order POST /v2/order Note This is an idempotent POST. Any duplicate request will be completed with response of the first request within 24 hours from the first request. This behaviour in conclustion with clientOrderId prevents potential order duplicates. Note You are able to make dry-run call before creating real orders. Add header: CP-EXECUTE-MODE: dry-run when execute this method. Permission: Order Request/Response body: Generic --> { \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"some info to be stored along the order\" , \"instrument\" : \"<NAME>\" , ...instrument specific fields... } <-- { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/instuments.response.json\" , \"TBD\" : \"//\" } CRYPTO_BUY (fait) --> { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_BUY.request.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Buy some BTC for 150.42$\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" , \"address\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"autoStart\" : false } <-- { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_BUY.json\" , \"TBD\" : \"//\" } CRYPTO_BUY (crypto) --> { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_BUY.request.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Buy 0.05142111 BTC for some $\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"amount\" : \"0.05142111\" , \"amountCurrency\" : \"BTC\" , \"address\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"autoStart\" : false } <-- { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_BUY.json\" , \"TBD\" : \"//\" } CRYPTO_SELL (fait) --> { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL.request.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell some BTC for 150.42$\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" } <-- { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL.response.json\" , \"TBD\" : \"//\" } CRYPTO_SELL (crypto) --> { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL.request.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell 0.05142111 BTC for some $\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"amount\" : \"0.05142111\" , \"amountCurrency\" : \"BTC\" } <-- { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL.json\" , \"TBD\" : \"//\" } CRYPTO_SELL_INFINITY --> { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL_INFINITY.request.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"My inifinity exchange order\" , \"instrument\" : \"CRYPTO_SELL_INFINITY\" , \"fiatCurrency\" : \"EUR\" , \"cryptoCurrency\" : \"BTC\" } <-- { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL_INFINITY.json\" , \"orderId\" : \"CPO-b3987b14-4395-43c0-b7c3-f627cb8d0e87\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"My inifinity exchange order. Any BTC deposit will automatically converts to EUR.\" , \"instrument\" : \"CRYPTO_SELL_INFINITY\" , \"fiatCurrency\" : \"EUR\" , \"cryptoCurrency\" : \"BTC\" , \"refill\" : { \"kind\" : \"BTC\" , \"network\" : \"mainnet\" , \"address\" : \"1xxXXxxXXxxXXxxXXxxXXxxXXxxXXxxXXx\" }, \"status\" : \"PROCESSING\" , \"state\" : \"WAITING_DEPOSIT\" , \"balance\" :{ \"BTC\" : \"0\" , \"USD\" : \"0\" }, \"cryptoDeposits\" : { \"count\" : 0 , \"totalAmount\" : \"0\" }, \"cryptoWithdrawals\" : { \"count\" : 0 , \"totalAmount\" : \"0\" } } Note Instrument specific fields are described in JSON schemas Fetch order Fetch single order by ID GET /v2/order/{{orderId}} CRYPTO_BUY { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_BUY.json\" , \"orderId\" : \"CPO-b3987b14-4395-43c0-b7c3-f627cb8d0e87\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Purchase some BTC (+0.xxxxx BTC, -150.42 USD)\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" , \"address\" : \"1xxXXxxXXxxXXxxXXxxXXxxXXxxXXxxXXx\" , \"status\" : \"PROCESSING\" , \"state\" : \"TRANSFERING_TO_EXCHANGE\" , \"balance\" :{ \"BTC\" : \"0\" , \"USD\" : \"150.42\" } } CRYPTO_SELL { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL.json\" , \"orderId\" : \"CPO-b3987b14-4395-43c0-b7c3-f627cb8d0e87\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell some BTC (-0.25 BTC, +xxxx.xx EUR)\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"EUR\" , \"cryptoCurrency\" : \"BTC\" , \"amount\" : \"0.25\" , \"amountCurrency\" : \"BTC\" , \"refill\" : { \"kind\" : \"BTC\" , \"network\" : \"mainnet\" , \"address\" : \"1xxXXxxXXxxXXxxXXxxXXxxXXxxXXxxXXx\" }, \"status\" : \"PROCESSING\" , \"state\" : \"WAITING_DEPOSIT\" , \"balance\" :{ \"BTC\" : \"0\" , \"USD\" : \"0\" }, \"cryptoDeposits\" : { \"count\" : 0 , \"totalAmount\" : \"0\" }, \"cryptoWithdrawals\" : { \"count\" : 0 , \"totalAmount\" : \"0\" } } CRYPTO_SELL_INFINITY { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL_INFINITY.json\" , \"orderId\" : \"CPO-b3987b14-4395-43c0-b7c3-f627cb8d0e87\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"My inifinity exchange order. Any BTC deposit will automatically converts to EUR.\" , \"instrument\" : \"CRYPTO_SELL_INFINITY\" , \"fiatCurrency\" : \"EUR\" , \"cryptoCurrency\" : \"BTC\" , \"refill\" : { \"kind\" : \"BTC\" , \"network\" : \"mainnet\" , \"address\" : \"1xxXXxxXXxxXXxxXXxxXXxxXXxxXXxxXXx\" }, \"status\" : \"PROCESSING\" , \"state\" : \"WAITING_DEPOSIT\" , \"balance\" :{ \"BTC\" : \"0\" , \"USD\" : \"0\" }, \"cryptoDeposits\" : { \"count\" : 0 , \"totalAmount\" : \"0\" }, \"cryptoWithdrawals\" : { \"count\" : 0 , \"totalAmount\" : \"0\" } } Permission: Order or View Breakpoints Breakpoints allow to control processing execution flow. List breakpoints Returns list of orders according filter defined by parameters GET /v2/order/{{orderId}}/breakpoint { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.breakpoints.json\" , \"orderId\" : \"CPO-b3987b14-4395-43c0-b7c3-f627cb8d0e87\" , \"instrument\" : \"CRYPTO_SELL\" , \"breakpoints\" : [ \"NEW\" : { \"signal\" : false , \"description\" : \"Order was created. Ready start processing.\" , \"active\" : false , \"//\" : \"TBD\" }, \"EXCHANGE\" : { \"signal\" : false , \"description\" : \"Order's balance enough to make exchange. Ready to exchange.\" , \"active\" : false , \"//\" : \"TBD\" } ] } Permission: Order or View Resume breakpoint POST /v2/order/{{orderId}}/breakpoint/{{breakpointName}} Permission: Order No request body Note The method will return HTTP 403 if breakpoint in not signal state Toggle breakpoint PUT /v2/order/{{orderId}}/breakpoint/{{breakpointName}} { \"active\" : true } Permission: Order Parameters: Agument Type Mandatory Descripton active BOOL YES true - makes breakpoint active (flow will pause when breakpoint reached) No request body Withdrawals This method allows to get all nformation about all withdrawal operations related to an order GET /v2/order/{{orderId}}/withdrawal Note The method will return HTTP 405 Not allowed, if order's instument does not support withdrawal Permission: Order or View Create withdrawal There are several cases when crypto amount holds on order balance. This method allows to make withdrawal amount to desired crypto address POST /v2/order/{{orderId}}/withdrawal Note The method will return HTTP 405 Not allowed, if order's instument does not support withdrawal Permission: Order Request body: { \"clientOperationId\" : \"123498-WITHDRAWAL-554-12\" , \"clientOperationTag\" : \"Some info... withdrawal by user request\" , \"targetAddress\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"amount\" : \"0.0493421\" } Fetch withdrawal This method allows to get status of a withdrawal operation. GET /v2/order/{{orderId}}/withdrawal/{{operationId}} Note The method will return HTTP 405 Not allowed, if order's instument does not support withdrawal Permission: Order or View","title":"REST API"},{"location":"api/#rest-api","text":"","title":"REST API"},{"location":"api/#authentication","text":"","title":"Authentication"},{"location":"api/#generating-an-api-key","text":"Before being able to sign any requests, you must create an API key via the CryptoPay support. Upon creating a key you will have 3 pieces of information which you must remember: Key - Randomly generated and provided by CryptoPay Secret - Randomly generated and provided by CryptoPay Passphrase - Provided by you to further secure your API access. CryptoPay stores the salted hash of your passphrase for verification, but cannot recover the passphrase if you forget it.","title":"Generating an API Key"},{"location":"api/#api-key-permissions","text":"You can restrict the functionality of API keys. Before creating the key, you must choose what permissions you would like the key to have. The permissions are:","title":"API Key Permissions"},{"location":"api/#merchant-permission","text":"Allows a key manage your sub-merchants.","title":"Merchant permission"},{"location":"api/#order-permission","text":"Allows a key to enter orders, as well as retrieve order data. This includes POST /order and several GET endpoints.","title":"Order permission"},{"location":"api/#view-permission","text":"Allows a key read permissions. This includes most of GET endpoints. Please refer to documentation below to see what API key permissions are required for a specific route.","title":"View permission"},{"location":"api/#creating-a-request","text":"All REST requests must contain the following headers: CP-ACCESS-KEY The api key as a string. CP-ACCESS-SIGN The base64-encoded signature (see Signing a Message). CP-ACCESS-TIMESTAMP A timestamp for your request. CP-ACCESS-PASSPHRASE The passphrase you specified when creating the API key. All request bodies should have content type application/json and be valid JSON.","title":"Creating a Request"},{"location":"api/#signing-a-message","text":"The CP-ACCESS-SIGN header is generated by creating a sha256 HMAC using the base64-decoded secret key on the prehash string timestamp + method + requestPath + body (where + represents string concatenation) and base64-encode the output. The timestamp value is the same as the CP-ACCESS-TIMESTAMP header. The body is the request body string or omitted if there is no request body (typically for GET requests). The method should be UPPER CASE like \"GET\", \"POST\", etc. Note Do not forget to base64-decode the alphanumeric secret string (resulting in 64 bytes) before using it as the key for HMAC. Also, base64-encode the digest output before sending in the header. Bash + OpenSSL SECRET = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" #TIMESTAMP=$(date +%s) TIMESTAMP = 1573753848 METHOD = \"POST\" URLPATH = \"/v2/order\" BODY = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' WHAT = \" ${ TIMESTAMP }${ METHOD }${ URLPATH }${ BODY } \" SECRET_KEY = $( echo -n \" ${ SECRET } \" | base64 --decode | hexdump -v -e '/1 \"%02x\"' ) echo -n \" ${ WHAT } \" | openssl dgst -sha256 -mac HMAC -macopt \"hexkey: $SECRET_KEY \" | xxd -r -p | base64 // Zg0U59GORi1dXCSnRfhFeOG/PKod538ij2AnwMFC5wA = NodeJS const secret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; //const timestamp = Date.now() / 1000; const timestamp = 1573753848 ; const method = \"POST\" ; const urlPath = \"/v2/order\" ; const body = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' ; const what = timestamp + method + urlPath + body ; const secretKey = Buffer . from ( secret , \"base64\" ); const hmac = require ( \"crypto\" ). createHmac ( \"sha256\" , secretKey ); console . log ( hmac . update ( what ). digest ( \"base64\" )); // Zg0U59GORi1dXCSnRfhFeOG/PKod538ij2AnwMFC5wA= PHP <?php $secret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; #$timestamp = time() $timestamp = 1573753848 ; $method = \"POST\" ; $urlPath = \"/v2/order\" ; $body = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' ; $what = $timestamp . $method . $urlPath . $body ; $secretKey = base64_decode ( $secret ); print ( base64_encode ( hash_hmac ( \"sha256\" , $what , $secretKey , true ))); # Zg0U59GORi1dXCSnRfhFeOG/PKod538ij2AnwMFC5wA=","title":"Signing a Message"},{"location":"api/#selecting-a-timestamp","text":"The CP-ACCESS-TIMESTAMP header MUST be number of seconds since Unix Epoch in UTC. Decimal values are allowed. Your timestamp must be within 30 seconds of the api service time or your request will be considered expired and rejected. We recommend using the time endpoint to query for the API server time if you believe there many be time skew between your server and the API servers.","title":"Selecting a Timestamp"},{"location":"api/#rate-limit","text":"The API server will return a 429 response (Too Many Requests) if you have spent your allowance completely. TBD: what is limit?","title":"Rate limit"},{"location":"api/#general-rules","text":"All endpoints return either a JSON object or array. Data is returned in ascending order. Oldest first, newest last. All time and timestamp related fields are in ISO 8601 . For GET endpoints, parameters must be sent as a query string . For POST, PUT, and DELETE endpoints, the parameters are sent in the request body with content type application/json . Success request codes: 2XX Client's mistakes: 4XX Server's errors: 5XX","title":"General rules"},{"location":"api/#v2time","text":"Note This endpoint does not require authentication. GET /v2/time { \"iso\" : \"2019-11-16T10:57:37.209Z\" , \"epoch\" : 1573901857.209 } The epoch field represents decimal seconds since Unix Epoch","title":"/v2/time"},{"location":"api/#v2merchant","text":"Merchant endpoint is available for sub-merchants management. Every request must be signed using the described authentication scheme.","title":"/v2/merchant"},{"location":"api/#list-merchants","text":"Returns list of sub-merchants according filter defined by parameters GET /v2/merchant Permission: Merchant or View Parameters: Agument Type Mandatory Descripton status ENUM NO Active, Installing, Blocked","title":"List merchants"},{"location":"api/#create-merchant","text":"Register a new merchant POST /v2/merchant Permission: Merchant Request body: { \"TBD\" : \"//\" }","title":"Create merchant"},{"location":"api/#update-merchant","text":"Update an existing merchant PUT /v2/merchant Permission: Merchant Request body: { \"TBD\" : \"//\" }","title":"Update merchant"},{"location":"api/#v2instument","text":"","title":"/v2/instument"},{"location":"api/#list-available-instuments","text":"Returns list of instuments GET /v2/instument <-- { \"CRYPTO_BUY\" : { \"breakpoints\" : [ \"NEW\" : { \"description\" : \"Order was created. Ready start processing.\" , \"active\" : false , \"//\" : \"TBD\" } ] }, \"CRYPTO_SELL\" : { \"breakpoints\" : [ \"NEW\" : { \"description\" : \"Order was created. Ready start processing.\" , \"active\" : false , \"//\" : \"TBD\" }, \"EXCHANGE\" : { \"description\" : \"Order's balance enough to make exchange. Ready to exchange.\" , \"active\" : false , \"//\" : \"TBD\" } ] }, \"CRYPTO_SELL_INFINITY\" : { \"//\" : \"TBD\" } } Permission: Order or View","title":"List available instuments"},{"location":"api/#v2order","text":"Order endpoint is available for order management. Every request must be signed using the described authentication scheme. Order statuses: NEW - Order registered and waiting for start processing PENDING - Still in progress ACCEPTED - Successfully completed REJECTED - Failure Order lifecycle: graph TD NEW --> PENDING PENDING --> PENDING PENDING --> ACCEPTED PENDING --> REJECTED","title":"/v2/order"},{"location":"api/#list-orders","text":"Returns list of orders according filter defined by parameters GET /v2/order Permission: Order or View Parameters: Agument Type Mandatory Descripton instument STRING NO Instrument name (like: CRYPTO_BUY) fromId STRING NO ID to get orders from INCLUSIVE startDate ISO 8601 NO Date to get orders from INCLUSIVE endDate ISO 8601 NO Date to get orders until EXCLUSIVE status STRING NO Status: NEW, PENDING, ACCEPTED or REJECTED limit INT NO Default 500; max 1000","title":"List orders"},{"location":"api/#create-order","text":"Register a new order POST /v2/order Note This is an idempotent POST. Any duplicate request will be completed with response of the first request within 24 hours from the first request. This behaviour in conclustion with clientOrderId prevents potential order duplicates. Note You are able to make dry-run call before creating real orders. Add header: CP-EXECUTE-MODE: dry-run when execute this method. Permission: Order Request/Response body: Generic --> { \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"some info to be stored along the order\" , \"instrument\" : \"<NAME>\" , ...instrument specific fields... } <-- { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/instuments.response.json\" , \"TBD\" : \"//\" } CRYPTO_BUY (fait) --> { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_BUY.request.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Buy some BTC for 150.42$\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" , \"address\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"autoStart\" : false } <-- { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_BUY.json\" , \"TBD\" : \"//\" } CRYPTO_BUY (crypto) --> { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_BUY.request.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Buy 0.05142111 BTC for some $\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"amount\" : \"0.05142111\" , \"amountCurrency\" : \"BTC\" , \"address\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"autoStart\" : false } <-- { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_BUY.json\" , \"TBD\" : \"//\" } CRYPTO_SELL (fait) --> { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL.request.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell some BTC for 150.42$\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" } <-- { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL.response.json\" , \"TBD\" : \"//\" } CRYPTO_SELL (crypto) --> { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL.request.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell 0.05142111 BTC for some $\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"amount\" : \"0.05142111\" , \"amountCurrency\" : \"BTC\" } <-- { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL.json\" , \"TBD\" : \"//\" } CRYPTO_SELL_INFINITY --> { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL_INFINITY.request.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"My inifinity exchange order\" , \"instrument\" : \"CRYPTO_SELL_INFINITY\" , \"fiatCurrency\" : \"EUR\" , \"cryptoCurrency\" : \"BTC\" } <-- { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL_INFINITY.json\" , \"orderId\" : \"CPO-b3987b14-4395-43c0-b7c3-f627cb8d0e87\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"My inifinity exchange order. Any BTC deposit will automatically converts to EUR.\" , \"instrument\" : \"CRYPTO_SELL_INFINITY\" , \"fiatCurrency\" : \"EUR\" , \"cryptoCurrency\" : \"BTC\" , \"refill\" : { \"kind\" : \"BTC\" , \"network\" : \"mainnet\" , \"address\" : \"1xxXXxxXXxxXXxxXXxxXXxxXXxxXXxxXXx\" }, \"status\" : \"PROCESSING\" , \"state\" : \"WAITING_DEPOSIT\" , \"balance\" :{ \"BTC\" : \"0\" , \"USD\" : \"0\" }, \"cryptoDeposits\" : { \"count\" : 0 , \"totalAmount\" : \"0\" }, \"cryptoWithdrawals\" : { \"count\" : 0 , \"totalAmount\" : \"0\" } } Note Instrument specific fields are described in JSON schemas","title":"Create order"},{"location":"api/#fetch-order","text":"Fetch single order by ID GET /v2/order/{{orderId}} CRYPTO_BUY { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_BUY.json\" , \"orderId\" : \"CPO-b3987b14-4395-43c0-b7c3-f627cb8d0e87\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Purchase some BTC (+0.xxxxx BTC, -150.42 USD)\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" , \"address\" : \"1xxXXxxXXxxXXxxXXxxXXxxXXxxXXxxXXx\" , \"status\" : \"PROCESSING\" , \"state\" : \"TRANSFERING_TO_EXCHANGE\" , \"balance\" :{ \"BTC\" : \"0\" , \"USD\" : \"150.42\" } } CRYPTO_SELL { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL.json\" , \"orderId\" : \"CPO-b3987b14-4395-43c0-b7c3-f627cb8d0e87\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell some BTC (-0.25 BTC, +xxxx.xx EUR)\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"EUR\" , \"cryptoCurrency\" : \"BTC\" , \"amount\" : \"0.25\" , \"amountCurrency\" : \"BTC\" , \"refill\" : { \"kind\" : \"BTC\" , \"network\" : \"mainnet\" , \"address\" : \"1xxXXxxXXxxXXxxXXxxXXxxXXxxXXxxXXx\" }, \"status\" : \"PROCESSING\" , \"state\" : \"WAITING_DEPOSIT\" , \"balance\" :{ \"BTC\" : \"0\" , \"USD\" : \"0\" }, \"cryptoDeposits\" : { \"count\" : 0 , \"totalAmount\" : \"0\" }, \"cryptoWithdrawals\" : { \"count\" : 0 , \"totalAmount\" : \"0\" } } CRYPTO_SELL_INFINITY { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.CRYPTO_SELL_INFINITY.json\" , \"orderId\" : \"CPO-b3987b14-4395-43c0-b7c3-f627cb8d0e87\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"My inifinity exchange order. Any BTC deposit will automatically converts to EUR.\" , \"instrument\" : \"CRYPTO_SELL_INFINITY\" , \"fiatCurrency\" : \"EUR\" , \"cryptoCurrency\" : \"BTC\" , \"refill\" : { \"kind\" : \"BTC\" , \"network\" : \"mainnet\" , \"address\" : \"1xxXXxxXXxxXXxxXXxxXXxxXXxxXXxxXXx\" }, \"status\" : \"PROCESSING\" , \"state\" : \"WAITING_DEPOSIT\" , \"balance\" :{ \"BTC\" : \"0\" , \"USD\" : \"0\" }, \"cryptoDeposits\" : { \"count\" : 0 , \"totalAmount\" : \"0\" }, \"cryptoWithdrawals\" : { \"count\" : 0 , \"totalAmount\" : \"0\" } } Permission: Order or View","title":"Fetch order"},{"location":"api/#breakpoints","text":"Breakpoints allow to control processing execution flow.","title":"Breakpoints"},{"location":"api/#list-breakpoints","text":"Returns list of orders according filter defined by parameters GET /v2/order/{{orderId}}/breakpoint { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/order.breakpoints.json\" , \"orderId\" : \"CPO-b3987b14-4395-43c0-b7c3-f627cb8d0e87\" , \"instrument\" : \"CRYPTO_SELL\" , \"breakpoints\" : [ \"NEW\" : { \"signal\" : false , \"description\" : \"Order was created. Ready start processing.\" , \"active\" : false , \"//\" : \"TBD\" }, \"EXCHANGE\" : { \"signal\" : false , \"description\" : \"Order's balance enough to make exchange. Ready to exchange.\" , \"active\" : false , \"//\" : \"TBD\" } ] } Permission: Order or View","title":"List breakpoints"},{"location":"api/#resume-breakpoint","text":"POST /v2/order/{{orderId}}/breakpoint/{{breakpointName}} Permission: Order No request body Note The method will return HTTP 403 if breakpoint in not signal state","title":"Resume breakpoint"},{"location":"api/#toggle-breakpoint","text":"PUT /v2/order/{{orderId}}/breakpoint/{{breakpointName}} { \"active\" : true } Permission: Order Parameters: Agument Type Mandatory Descripton active BOOL YES true - makes breakpoint active (flow will pause when breakpoint reached) No request body","title":"Toggle breakpoint"},{"location":"api/#withdrawals","text":"This method allows to get all nformation about all withdrawal operations related to an order GET /v2/order/{{orderId}}/withdrawal Note The method will return HTTP 405 Not allowed, if order's instument does not support withdrawal Permission: Order or View","title":"Withdrawals"},{"location":"api/#create-withdrawal","text":"There are several cases when crypto amount holds on order balance. This method allows to make withdrawal amount to desired crypto address POST /v2/order/{{orderId}}/withdrawal Note The method will return HTTP 405 Not allowed, if order's instument does not support withdrawal Permission: Order Request body: { \"clientOperationId\" : \"123498-WITHDRAWAL-554-12\" , \"clientOperationTag\" : \"Some info... withdrawal by user request\" , \"targetAddress\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"amount\" : \"0.0493421\" }","title":"Create withdrawal"},{"location":"api/#fetch-withdrawal","text":"This method allows to get status of a withdrawal operation. GET /v2/order/{{orderId}}/withdrawal/{{operationId}} Note The method will return HTTP 405 Not allowed, if order's instument does not support withdrawal Permission: Order or View","title":"Fetch withdrawal"},{"location":"events/","text":"Events Signing event messages The signature is generated by creating a sha256 HMAC using the base64-decoded secret key on the prehash binary data timestamp + message (where + represents concatenation) and base64-encode the output. The timestamp value pass along with callback request. See details for concrete callback endpoint below. Note: Do not forget to base64-decode the alphanumeric secret string (resulting in 64 bytes) before using it as the key for HMAC. Bash + OpenSSL RECEIVED_SIGNATURE = \"ZPRij68bsUH6C/TJ/2fg5iZt88Cc2onqdU2RfubwUVA=\" RECEIVED_TIMESTAMP = 1573753848 RECEIVED_MESSAGE = '{\"jsonrpc\":\"2.0\",\"method\":\"somethingChanged\",\"params\":{\"id\":\"1490548887804-XA-1112-TU\"}}' WHAT = \" ${ RECEIVED_TIMESTAMP }${ RECEIVED_MESSAGE } \" NOTIFICATION_SECRET = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" SECRET_KEY = $( echo -n \" ${ NOTIFICATION_SECRET } \" | base64 --decode | hexdump -v -e '/1 \"%02x\"' ) CALCULATED_SIGNATURE = $( echo -n \" ${ WHAT } \" | openssl dgst -sha256 -mac HMAC -macopt \"hexkey: $SECRET_KEY \" | xxd -r -p | base64 ) if [ \" ${ CALCULATED_SIGNATURE } \" == \" ${ RECEIVED_SIGNATURE } \" ] ; then echo \"Received legitimate message\" fi NodeJS const receivedSignature = \"ZPRij68bsUH6C/TJ/2fg5iZt88Cc2onqdU2RfubwUVA=\" ; const receivedTimestamp = Buffer . from ( \"1573753848\" ); const receivedMessage = Buffer . from ( '{\"jsonrpc\":\"2.0\",\"method\":\"somethingChanged\",\"params\":{\"id\":\"1490548887804-XA-1112-TU\"}}' ); const what = Buffer . concat ([ receivedTimestamp , receivedMessage ]); const notificationSecret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; const secretKey = Buffer . from ( notificationSecret , \"base64\" ); const hmac = require ( \"crypto\" ). createHmac ( \"sha256\" , secretKey ); const calculatedSignature = hmac . update ( what ). digest ( \"base64\" ); if ( calculatedSignature === receivedSignature ) { console . log ( \"Received legitimate message\" ); } PHP <?php $receivedSignature = \"ZPRij68bsUH6C/TJ/2fg5iZt88Cc2onqdU2RfubwUVA=\" ; $receivedTimestamp = \"1573753848\" ; $receivedMessage = '{\"jsonrpc\":\"2.0\",\"method\":\"somethingChanged\",\"params\":{\"id\":\"1490548887804-XA-1112-TU\"}}' ; $what = $receivedTimestamp . $receivedMessage ; $notificationSecret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; $secretKey = base64_decode ( $notificationSecret ); $calculatedSignature = base64_encode ( hash_hmac ( \"sha256\" , $what , $secretKey , true )); if ( $calculatedSignature == $receivedSignature ) { print ( \"Received legitimate message\" ); }","title":"Events"},{"location":"events/#events","text":"","title":"Events"},{"location":"events/#signing-event-messages","text":"The signature is generated by creating a sha256 HMAC using the base64-decoded secret key on the prehash binary data timestamp + message (where + represents concatenation) and base64-encode the output. The timestamp value pass along with callback request. See details for concrete callback endpoint below. Note: Do not forget to base64-decode the alphanumeric secret string (resulting in 64 bytes) before using it as the key for HMAC. Bash + OpenSSL RECEIVED_SIGNATURE = \"ZPRij68bsUH6C/TJ/2fg5iZt88Cc2onqdU2RfubwUVA=\" RECEIVED_TIMESTAMP = 1573753848 RECEIVED_MESSAGE = '{\"jsonrpc\":\"2.0\",\"method\":\"somethingChanged\",\"params\":{\"id\":\"1490548887804-XA-1112-TU\"}}' WHAT = \" ${ RECEIVED_TIMESTAMP }${ RECEIVED_MESSAGE } \" NOTIFICATION_SECRET = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" SECRET_KEY = $( echo -n \" ${ NOTIFICATION_SECRET } \" | base64 --decode | hexdump -v -e '/1 \"%02x\"' ) CALCULATED_SIGNATURE = $( echo -n \" ${ WHAT } \" | openssl dgst -sha256 -mac HMAC -macopt \"hexkey: $SECRET_KEY \" | xxd -r -p | base64 ) if [ \" ${ CALCULATED_SIGNATURE } \" == \" ${ RECEIVED_SIGNATURE } \" ] ; then echo \"Received legitimate message\" fi NodeJS const receivedSignature = \"ZPRij68bsUH6C/TJ/2fg5iZt88Cc2onqdU2RfubwUVA=\" ; const receivedTimestamp = Buffer . from ( \"1573753848\" ); const receivedMessage = Buffer . from ( '{\"jsonrpc\":\"2.0\",\"method\":\"somethingChanged\",\"params\":{\"id\":\"1490548887804-XA-1112-TU\"}}' ); const what = Buffer . concat ([ receivedTimestamp , receivedMessage ]); const notificationSecret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; const secretKey = Buffer . from ( notificationSecret , \"base64\" ); const hmac = require ( \"crypto\" ). createHmac ( \"sha256\" , secretKey ); const calculatedSignature = hmac . update ( what ). digest ( \"base64\" ); if ( calculatedSignature === receivedSignature ) { console . log ( \"Received legitimate message\" ); } PHP <?php $receivedSignature = \"ZPRij68bsUH6C/TJ/2fg5iZt88Cc2onqdU2RfubwUVA=\" ; $receivedTimestamp = \"1573753848\" ; $receivedMessage = '{\"jsonrpc\":\"2.0\",\"method\":\"somethingChanged\",\"params\":{\"id\":\"1490548887804-XA-1112-TU\"}}' ; $what = $receivedTimestamp . $receivedMessage ; $notificationSecret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; $secretKey = base64_decode ( $notificationSecret ); $calculatedSignature = base64_encode ( hash_hmac ( \"sha256\" , $what , $secretKey , true )); if ( $calculatedSignature == $receivedSignature ) { print ( \"Received legitimate message\" ); }","title":"Signing event messages"},{"location":"notifier/","text":"Notifier Notifier is a Notification Server that implements Publish\u2013Subscribe Pattern. Main responsibility is to deliver callback messages via Webhooks and other messaging providers. Recommendation Although notification includes real and valid data, we recommend to use notifications just as notifications and retvieve data via appropriate method of Pull API ( REST API for example). In general, any notifications system by design may delay messages. Good practice for end-application is to check status via Pull API if expected message was not received in expected time frame. General information Use-cases sequenceDiagram participant Subscriber1 participant Subscriber2 participant `Notifier` participant Publisher opt Event A happend Publisher->>`Notifier`: Message A for \"my\" topic `Notifier`->>`Notifier`: Skip, just audit end Subscriber2->>+`Notifier`: Subscribe \"my\" topic `Notifier`-->>-Subscriber2: OK opt Event B happend Publisher->>`Notifier`: Message B for \"my\" topic `Notifier`->>+Subscriber2: Message B for \"my\" topic Subscriber2-->>-`Notifier`: OK end Subscriber1->>+`Notifier`: Subscribe \"my\" topic `Notifier`-->>-Subscriber1: OK opt Event C happend Publisher->>`Notifier`: Message C for \"my\" topic `Notifier`->>+Subscriber2: Message C for \"my\" topic Subscriber2-->>-`Notifier`: OK `Notifier`->>+Subscriber1: Message C for \"my\" topic Subscriber1-->>-`Notifier`: OK end Subscriber1->>+`Notifier`: UNsubscribe \"my\" topic `Notifier`-->>-Subscriber1: OK opt Event D happend Publisher->>`Notifier`: Message D for \"my\" topic `Notifier`->>+Subscriber2: Message D for \"my\" topic Subscriber2-->>-`Notifier`: OK end Delivery Messages are sent immediately after an operation was performed. Notifier records the fact of message delivery to your system after receiving the response from your system. If message delivery is failed the server will retry with delay between attempts according to a scale was choosen at subscription phase. For example powers of two scale will retry delivery until the period does not exceed 16384 seconds (~4.5hours): 1, 2, 4, 8, 16, ..., 16384(max). Notification server performs attempts to deliver a message within 3 days. Selecting message format Along with setup your notification endpoint, you may choose message format. JSON-RPC Using JSON-RPC in notification manner --> { \"jsonrpc\" : \"2.0\" , \"method\" : \"somethingChanged\" , \"params\" : { \"id\" : \"68ac6741f92d41fbbc894ab406fcc91d\" , ...... }} --> { \"jsonrpc\" : \"2.0\" , \"method\" : \"somethingAdded\" , \"params\" : { \"id\" : \"3d80cbbe\" , ...... }} Protocol Buffers Version 2 Using Protocol Buffers for message serialization. See definition .proto file for details. Message security Notifier provides Signing and Encrypt methods to verify that the request is legitimate. Signing message Message signature provides by a Publisher service. Notifier does not modify provided signature, just deliver it along with message. See for details in events documentation. Encrypt message (Optional) Optionally (along with signing), you may setup(via Management API) an encrypt password , messages will be encrypted. Bash + OpenSSL TBD NodeJS TBD PHP TBD Webhooks Webhooks are \"user-defined HTTP callbacks\". When an event occurs, Notifier makes an HTTP request to the URI configured for the webhook. Warning Your endpoint should ALWAYS return a valid HTTP response with HTTP status 2XX. If you do not do this then Notifier will think the hook failed and retry it. Headers Notification server will include following headers to each request: NF-TIMESTAMP - A timestamp that was used in signature calculation NF-SIGN - The base64-encoded signature Security SSL verification SSL Verification enables automatically for URL scheme https: . No additional configuration required. Optional If you specify a CA Certificates (via Merchant Management API), it will be used to verify the SSL certificate of the webhook endpoint. Otherwise the SSL certificate of the webhook endpoint is verified based on an internal list of Certificate Authorities. Secret token If you setup a secret token (via Merchant Management API), it will be sent with the hook request in the NF-TOKEN HTTP header.","title":"Notifier"},{"location":"notifier/#notifier","text":"Notifier is a Notification Server that implements Publish\u2013Subscribe Pattern. Main responsibility is to deliver callback messages via Webhooks and other messaging providers. Recommendation Although notification includes real and valid data, we recommend to use notifications just as notifications and retvieve data via appropriate method of Pull API ( REST API for example). In general, any notifications system by design may delay messages. Good practice for end-application is to check status via Pull API if expected message was not received in expected time frame.","title":"Notifier"},{"location":"notifier/#general-information","text":"","title":"General information"},{"location":"notifier/#use-cases","text":"sequenceDiagram participant Subscriber1 participant Subscriber2 participant `Notifier` participant Publisher opt Event A happend Publisher->>`Notifier`: Message A for \"my\" topic `Notifier`->>`Notifier`: Skip, just audit end Subscriber2->>+`Notifier`: Subscribe \"my\" topic `Notifier`-->>-Subscriber2: OK opt Event B happend Publisher->>`Notifier`: Message B for \"my\" topic `Notifier`->>+Subscriber2: Message B for \"my\" topic Subscriber2-->>-`Notifier`: OK end Subscriber1->>+`Notifier`: Subscribe \"my\" topic `Notifier`-->>-Subscriber1: OK opt Event C happend Publisher->>`Notifier`: Message C for \"my\" topic `Notifier`->>+Subscriber2: Message C for \"my\" topic Subscriber2-->>-`Notifier`: OK `Notifier`->>+Subscriber1: Message C for \"my\" topic Subscriber1-->>-`Notifier`: OK end Subscriber1->>+`Notifier`: UNsubscribe \"my\" topic `Notifier`-->>-Subscriber1: OK opt Event D happend Publisher->>`Notifier`: Message D for \"my\" topic `Notifier`->>+Subscriber2: Message D for \"my\" topic Subscriber2-->>-`Notifier`: OK end","title":"Use-cases"},{"location":"notifier/#delivery","text":"Messages are sent immediately after an operation was performed. Notifier records the fact of message delivery to your system after receiving the response from your system. If message delivery is failed the server will retry with delay between attempts according to a scale was choosen at subscription phase. For example powers of two scale will retry delivery until the period does not exceed 16384 seconds (~4.5hours): 1, 2, 4, 8, 16, ..., 16384(max). Notification server performs attempts to deliver a message within 3 days.","title":"Delivery"},{"location":"notifier/#selecting-message-format","text":"Along with setup your notification endpoint, you may choose message format.","title":"Selecting message format"},{"location":"notifier/#json-rpc","text":"Using JSON-RPC in notification manner --> { \"jsonrpc\" : \"2.0\" , \"method\" : \"somethingChanged\" , \"params\" : { \"id\" : \"68ac6741f92d41fbbc894ab406fcc91d\" , ...... }} --> { \"jsonrpc\" : \"2.0\" , \"method\" : \"somethingAdded\" , \"params\" : { \"id\" : \"3d80cbbe\" , ...... }}","title":"JSON-RPC"},{"location":"notifier/#protocol-buffers-version-2","text":"Using Protocol Buffers for message serialization. See definition .proto file for details.","title":"Protocol Buffers Version 2"},{"location":"notifier/#message-security","text":"Notifier provides Signing and Encrypt methods to verify that the request is legitimate.","title":"Message security"},{"location":"notifier/#signing-message","text":"Message signature provides by a Publisher service. Notifier does not modify provided signature, just deliver it along with message. See for details in events documentation.","title":"Signing message"},{"location":"notifier/#encrypt-message-optional","text":"Optionally (along with signing), you may setup(via Management API) an encrypt password , messages will be encrypted. Bash + OpenSSL TBD NodeJS TBD PHP TBD","title":"Encrypt message (Optional)"},{"location":"notifier/#webhooks","text":"Webhooks are \"user-defined HTTP callbacks\". When an event occurs, Notifier makes an HTTP request to the URI configured for the webhook. Warning Your endpoint should ALWAYS return a valid HTTP response with HTTP status 2XX. If you do not do this then Notifier will think the hook failed and retry it.","title":"Webhooks"},{"location":"notifier/#headers","text":"Notification server will include following headers to each request: NF-TIMESTAMP - A timestamp that was used in signature calculation NF-SIGN - The base64-encoded signature","title":"Headers"},{"location":"notifier/#security","text":"","title":"Security"},{"location":"notifier/#ssl-verification","text":"SSL Verification enables automatically for URL scheme https: . No additional configuration required. Optional If you specify a CA Certificates (via Merchant Management API), it will be used to verify the SSL certificate of the webhook endpoint. Otherwise the SSL certificate of the webhook endpoint is verified based on an internal list of Certificate Authorities.","title":"SSL verification"},{"location":"notifier/#secret-token","text":"If you setup a secret token (via Merchant Management API), it will be sent with the hook request in the NF-TOKEN HTTP header.","title":"Secret token"},{"location":"release-notes/","text":"Release Notes TBD","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"TBD","title":"Release Notes"},{"location":"terminology/","text":"Terminology Merhcant TBD Instrument CryptoPay's Instrument defines kind of service. An instrument decribes how to process an order. Different instrument has own set of attributes according kind field. Note Instrument defines applied commissions (may be overriden on in merchant's configuration) Each merchant has own set of allowed instument Instrument kinds Kind Description CRYPTO_BUY Buy crypo asset (convert fiat to crypto). One time order with fixed amount. CRYPTO_SELL Sell crypo asset (convert crypto to fiat). One time order with fixed amount. CRYPTO_SELL_INFINITY Sell crypo asset (convert crypto to fiat). The Order works infinitely (may be cancelled via API). Each crypto deposit will automatically scheduled processing (breakpoints allowed) CRYPTO_BUY sequenceDiagram User->>+B2C Merchant: Goes to site B2C Merchant->>+B2B Merchant: Request crypto payment B2B Merchant->>+CryptoPay: Get instruments CryptoPay-->>-B2B Merchant: Currencies, rates, etc. B2B Merchant-->>-B2C Merchant: Available instuments B2C Merchant-->>-User: Render instuments User->>+B2C Merchant: Request order B2C Merchant->>+B2B Merchant: Create order B2B Merchant->>+CryptoPay: Create order CryptoPay->>+Exchange: Get rate Exchange-->>-CryptoPay: Current rate CryptoPay->>CryptoPay: Calulate cash flow CryptoPay-->>B2B Merchant: Order details B2B Merchant-->>B2C Merchant: Order attribures B2C Merchant-->>User: Render order details opt Skip for dry-run mode User->>B2C Merchant: Accept order details B2C Merchant->>B2B Merchant: Approve order B2B Merchant->>+CryptoPay: Start order CryptoPay-->>B2B Merchant: Started B2B Merchant-->>B2C Merchant: Started B2C Merchant-->>User: Started CryptoPay->>+Exchange: Get rate Exchange-->>-CryptoPay: Current rate CryptoPay->>+Exchange: Make exchange Exchange-->>-CryptoPay: Exchange approved CryptoPay->>+Wallet: Make withdrawal Wallet-->>-CryptoPay: Withdrawal approved CryptoPay-->>-B2B Merchant: Notify (READY TO SHIP) B2B Merchant-->>-B2C Merchant: Notify (ACCEPTED) B2C Merchant-->>-User: Final details end CRYPTO_SELL sequenceDiagram User->>+B2C Merchant: Goes to site B2C Merchant->>+B2B Merchant: Request crypto payment B2B Merchant->>+CryptoPay: Get instruments CryptoPay-->>-B2B Merchant: Currencies, rates, etc. B2B Merchant-->>-B2C Merchant: Available instuments B2C Merchant-->>-User: Render instuments User->>+B2C Merchant: Request order B2C Merchant->>+B2B Merchant: Create order B2B Merchant->>+CryptoPay: Create order CryptoPay->>+Exchange: Get rate Exchange-->>-CryptoPay: Current rate opt Skip for dry-run mode CryptoPay->>+Wallet: Generate new address Wallet-->>-CryptoPay: New address end CryptoPay->>CryptoPay: Calulate cash flow CryptoPay-->>B2B Merchant: Order details B2B Merchant-->>B2C Merchant: Order attribures B2C Merchant-->>User: Render order details opt Skip for dry-run mode Wallet-->>CryptoPay: Confirmations: 0 (configurable) CryptoPay-->>B2B Merchant: Notify (PAID) B2B Merchant-->>B2C Merchant: Notify (DEPOSIT) B2C Merchant-->>User: Deposit processing Wallet-->>CryptoPay: Confirmations: 1 (configurable) CryptoPay->>+Exchange: Make exchange Exchange-->>-CryptoPay: Exchange approved Wallet-->>CryptoPay: Confirmations: X (configurable) CryptoPay-->>-B2B Merchant: Notify (READY TO SHIP) B2B Merchant-->>-B2C Merchant: Notify (ACCEPTED) B2C Merchant-->>-User: Final details end CRYPTO_SELL_INFINITY sequenceDiagram User->>+B2C Merchant: Request order B2C Merchant->>+B2B Merchant: Create order B2B Merchant->>+CryptoPay: Create order CryptoPay->>+Exchange: Get rate Exchange-->>-CryptoPay: Current rate CryptoPay->>+Wallet: Generate new address Wallet-->>-CryptoPay: New address CryptoPay->>CryptoPay: Calulate cash flow CryptoPay-->>B2B Merchant: Order details B2B Merchant-->>B2C Merchant: Order attribures B2C Merchant-->>User: Render order details opt Infinity Loop Wallet-->>CryptoPay: Confirmations: 0 (configurable) CryptoPay-->>B2B Merchant: Notify (PAID) B2B Merchant-->>B2C Merchant: Notify (DEPOSIT) B2C Merchant-->>User: Deposit processing Wallet-->>CryptoPay: Confirmations: 1 (configurable) CryptoPay->>+Exchange: Make exchange Exchange-->>-CryptoPay: Exchange approved Wallet-->>CryptoPay: Confirmations: X (configurable) CryptoPay-->>-B2B Merchant: Notify (READY TO SHIP) B2B Merchant-->>-B2C Merchant: Notify (ACCEPTED) B2C Merchant-->>-User: Final details end Order CryptoPay Order is time-sensitive payment requests addressed to specific buyers. In another words, Order is set of attributes like fiatCurrency , cryptoCurrency , amount , etc. TBD Breakpoint Breakpoint is a point in instrument 's workflow where processing may pauses for manual approve. Each instument provides own set of breakpoints. Breakpoints by default settings may be active or inactive. Instrument's default behavior may be overridden in merchant 's settings or via order creation attibutes. TBD","title":"Terminology"},{"location":"terminology/#terminology","text":"","title":"Terminology"},{"location":"terminology/#merhcant","text":"TBD","title":"Merhcant"},{"location":"terminology/#instrument","text":"CryptoPay's Instrument defines kind of service. An instrument decribes how to process an order. Different instrument has own set of attributes according kind field. Note Instrument defines applied commissions (may be overriden on in merchant's configuration) Each merchant has own set of allowed instument","title":"Instrument"},{"location":"terminology/#instrument-kinds","text":"Kind Description CRYPTO_BUY Buy crypo asset (convert fiat to crypto). One time order with fixed amount. CRYPTO_SELL Sell crypo asset (convert crypto to fiat). One time order with fixed amount. CRYPTO_SELL_INFINITY Sell crypo asset (convert crypto to fiat). The Order works infinitely (may be cancelled via API). Each crypto deposit will automatically scheduled processing (breakpoints allowed)","title":"Instrument kinds"},{"location":"terminology/#crypto_buy","text":"sequenceDiagram User->>+B2C Merchant: Goes to site B2C Merchant->>+B2B Merchant: Request crypto payment B2B Merchant->>+CryptoPay: Get instruments CryptoPay-->>-B2B Merchant: Currencies, rates, etc. B2B Merchant-->>-B2C Merchant: Available instuments B2C Merchant-->>-User: Render instuments User->>+B2C Merchant: Request order B2C Merchant->>+B2B Merchant: Create order B2B Merchant->>+CryptoPay: Create order CryptoPay->>+Exchange: Get rate Exchange-->>-CryptoPay: Current rate CryptoPay->>CryptoPay: Calulate cash flow CryptoPay-->>B2B Merchant: Order details B2B Merchant-->>B2C Merchant: Order attribures B2C Merchant-->>User: Render order details opt Skip for dry-run mode User->>B2C Merchant: Accept order details B2C Merchant->>B2B Merchant: Approve order B2B Merchant->>+CryptoPay: Start order CryptoPay-->>B2B Merchant: Started B2B Merchant-->>B2C Merchant: Started B2C Merchant-->>User: Started CryptoPay->>+Exchange: Get rate Exchange-->>-CryptoPay: Current rate CryptoPay->>+Exchange: Make exchange Exchange-->>-CryptoPay: Exchange approved CryptoPay->>+Wallet: Make withdrawal Wallet-->>-CryptoPay: Withdrawal approved CryptoPay-->>-B2B Merchant: Notify (READY TO SHIP) B2B Merchant-->>-B2C Merchant: Notify (ACCEPTED) B2C Merchant-->>-User: Final details end","title":"CRYPTO_BUY"},{"location":"terminology/#crypto_sell","text":"sequenceDiagram User->>+B2C Merchant: Goes to site B2C Merchant->>+B2B Merchant: Request crypto payment B2B Merchant->>+CryptoPay: Get instruments CryptoPay-->>-B2B Merchant: Currencies, rates, etc. B2B Merchant-->>-B2C Merchant: Available instuments B2C Merchant-->>-User: Render instuments User->>+B2C Merchant: Request order B2C Merchant->>+B2B Merchant: Create order B2B Merchant->>+CryptoPay: Create order CryptoPay->>+Exchange: Get rate Exchange-->>-CryptoPay: Current rate opt Skip for dry-run mode CryptoPay->>+Wallet: Generate new address Wallet-->>-CryptoPay: New address end CryptoPay->>CryptoPay: Calulate cash flow CryptoPay-->>B2B Merchant: Order details B2B Merchant-->>B2C Merchant: Order attribures B2C Merchant-->>User: Render order details opt Skip for dry-run mode Wallet-->>CryptoPay: Confirmations: 0 (configurable) CryptoPay-->>B2B Merchant: Notify (PAID) B2B Merchant-->>B2C Merchant: Notify (DEPOSIT) B2C Merchant-->>User: Deposit processing Wallet-->>CryptoPay: Confirmations: 1 (configurable) CryptoPay->>+Exchange: Make exchange Exchange-->>-CryptoPay: Exchange approved Wallet-->>CryptoPay: Confirmations: X (configurable) CryptoPay-->>-B2B Merchant: Notify (READY TO SHIP) B2B Merchant-->>-B2C Merchant: Notify (ACCEPTED) B2C Merchant-->>-User: Final details end","title":"CRYPTO_SELL"},{"location":"terminology/#crypto_sell_infinity","text":"sequenceDiagram User->>+B2C Merchant: Request order B2C Merchant->>+B2B Merchant: Create order B2B Merchant->>+CryptoPay: Create order CryptoPay->>+Exchange: Get rate Exchange-->>-CryptoPay: Current rate CryptoPay->>+Wallet: Generate new address Wallet-->>-CryptoPay: New address CryptoPay->>CryptoPay: Calulate cash flow CryptoPay-->>B2B Merchant: Order details B2B Merchant-->>B2C Merchant: Order attribures B2C Merchant-->>User: Render order details opt Infinity Loop Wallet-->>CryptoPay: Confirmations: 0 (configurable) CryptoPay-->>B2B Merchant: Notify (PAID) B2B Merchant-->>B2C Merchant: Notify (DEPOSIT) B2C Merchant-->>User: Deposit processing Wallet-->>CryptoPay: Confirmations: 1 (configurable) CryptoPay->>+Exchange: Make exchange Exchange-->>-CryptoPay: Exchange approved Wallet-->>CryptoPay: Confirmations: X (configurable) CryptoPay-->>-B2B Merchant: Notify (READY TO SHIP) B2B Merchant-->>-B2C Merchant: Notify (ACCEPTED) B2C Merchant-->>-User: Final details end","title":"CRYPTO_SELL_INFINITY"},{"location":"terminology/#order","text":"CryptoPay Order is time-sensitive payment requests addressed to specific buyers. In another words, Order is set of attributes like fiatCurrency , cryptoCurrency , amount , etc. TBD","title":"Order"},{"location":"terminology/#breakpoint","text":"Breakpoint is a point in instrument 's workflow where processing may pauses for manual approve. Each instument provides own set of breakpoints. Breakpoints by default settings may be active or inactive. Instrument's default behavior may be overridden in merchant 's settings or via order creation attibutes. TBD","title":"Breakpoint"},{"location":"websocket-api/","text":"WebSocket API Overview TBD TBD TBD TBD TBD TBD","title":"WebSocket API"},{"location":"websocket-api/#websocket-api","text":"","title":"WebSocket API"},{"location":"websocket-api/#overview","text":"TBD","title":"Overview"},{"location":"websocket-api/#tbd","text":"","title":"TBD"},{"location":"websocket-api/#tbd_1","text":"","title":"TBD"},{"location":"websocket-api/#tbd_2","text":"","title":"TBD"},{"location":"websocket-api/#tbd_3","text":"TBD","title":"TBD"}]}