{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CryptoPay CryptoPay offers a crypto processing features like a: Fiat to Crypto exchange Crypto to Fiat exchange Crypto payments (like buying goods)","title":"Overview"},{"location":"#cryptopay","text":"CryptoPay offers a crypto processing features like a: Fiat to Crypto exchange Crypto to Fiat exchange Crypto payments (like buying goods)","title":"CryptoPay"},{"location":"api/","text":"REST API Authentication Generating an API Key Before being able to sign any requests, you must create an API key via the CryptoPay support. Upon creating a key you will have 3 pieces of information which you must remember: Key - Randomly generated and provided by CryptoPay Secret - Randomly generated and provided by CryptoPay Passphrase - Provided by you to further secure your API access. CryptoPay stores the salted hash of your passphrase for verification, but cannot recover the passphrase if you forget it. API Key Permissions You can restrict the functionality of API keys. Before creating the key, you must choose what permissions you would like the key to have. The permissions are: Merchant permission Allows a key manage your sub-merchants. Order permission Allows a key to enter orders, as well as retrieve order data. This includes POST /order and several GET endpoints. View permission Allows a key read permissions. This includes most of GET endpoints. Please refer to documentation below to see what API key permissions are required for a specific route. Creating a Request All REST requests must contain the following headers: CP-ACCESS-KEY The api key as a string. CP-ACCESS-SIGN The base64-encoded signature (see Signing a Message). CP-ACCESS-TIMESTAMP A timestamp for your request. CP-ACCESS-PASSPHRASE The passphrase you specified when creating the API key. All request bodies should have content type application/json and be valid JSON. Signing a Message The CP-ACCESS-SIGN header is generated by creating a sha256 HMAC using the base64-decoded secret key on the prehash string timestamp + method + requestPath + body (where + represents string concatenation) and base64-encode the output. The timestamp value is the same as the CP-ACCESS-TIMESTAMP header. The body is the request body string or omitted if there is no request body (typically for GET requests). The method should be UPPER CASE like \"GET\", \"POST\", etc. Note Do not forget to base64-decode the alphanumeric secret string (resulting in 64 bytes) before using it as the key for HMAC. Also, base64-encode the digest output before sending in the header. Bash + OpenSSL SECRET = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" #TIMESTAMP=$(date +%s) TIMESTAMP = 1573753848 METHOD = \"POST\" URLPATH = \"/v2/order\" BODY = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' WHAT = \" ${ TIMESTAMP }${ METHOD }${ URLPATH }${ BODY } \" SECRET_KEY = $( echo -n \" ${ SECRET } \" | base64 --decode | hexdump -v -e '/1 \"%02x\"' ) echo -n \" ${ WHAT } \" | openssl dgst -sha256 -mac HMAC -macopt \"hexkey: $SECRET_KEY \" | xxd -r -p | base64 // Zg0U59GORi1dXCSnRfhFeOG/PKod538ij2AnwMFC5wA = NodeJS const secret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; //const timestamp = Date.now() / 1000; const timestamp = 1573753848 ; const method = \"POST\" ; const urlPath = \"/v2/order\" ; const body = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' ; const what = timestamp + method + urlPath + body ; const secretKey = Buffer . from ( secret , \"base64\" ); const hmac = require ( \"crypto\" ). createHmac ( \"sha256\" , secretKey ); console . log ( hmac . update ( what ). digest ( \"base64\" )); // Zg0U59GORi1dXCSnRfhFeOG/PKod538ij2AnwMFC5wA= PHP <?php $secret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; #$timestamp = time() $timestamp = 1573753848 ; $method = \"POST\" ; $urlPath = \"/v2/order\" ; $body = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' ; $what = $timestamp . $method . $urlPath . $body ; $secretKey = base64_decode ( $secret ); print ( base64_encode ( hash_hmac ( \"sha256\" , $what , $secretKey , true ))); # Zg0U59GORi1dXCSnRfhFeOG/PKod538ij2AnwMFC5wA= Selecting a Timestamp The CP-ACCESS-TIMESTAMP header MUST be number of seconds since Unix Epoch in UTC. Decimal values are allowed. Your timestamp must be within 30 seconds of the api service time or your request will be considered expired and rejected. We recommend using the time endpoint to query for the API server time if you believe there many be time skew between your server and the API servers. Rate limit The API server will return a 429 response (Too Many Requests) if you have spent your allowance completely. TBD: what is limit? General rules All endpoints return either a JSON object or array. Data is returned in ascending order. Oldest first, newest last. All time and timestamp related fields are in ISO 8601 . For GET endpoints, parameters must be sent as a query string . For POST, PUT, and DELETE endpoints, the parameters are sent in the request body with content type application/json . Success request codes: 2XX Client's mistakes: 4XX Server's errors: 5XX /v2/time Note This endpoint does not require authentication. GET /v2/time { \"iso\" : \"2019-11-16T10:57:37.209Z\" , \"epoch\" : 1573901857.209 } The epoch field represents decimal seconds since Unix Epoch /v2/merchant Merchant endpoint is available for sub-merchants management. Every request must be signed using the described authentication scheme. List sub-merchants Returns list of sub-merchants according filter defined by parameters GET /v2/merchant TBD Create sub-merchant TBD Update sub-merchants TBD /v2/order Order endpoint is available for order management. Every request must be signed using the described authentication scheme. Order statuses: NEW - Order registered and waiting for start processing PENDING - Still in progress ACCEPTED - Successfully completed REJECTED - Failure Order lifecycle: graph TD NEW --> PENDING PENDING --> PENDING PENDING --> ACCEPTED PENDING --> REJECTED List orders Returns list of orders according filter defined by parameters GET /v2/order Permission: Order or View Parameters: Agument Type Mandatory Descripton instument STRING NO Instrument name (like: CRYPTO_BUY) fromId STRING NO ID to get orders from INCLUSIVE startDate ISO 8601 NO Date to get orders from INCLUSIVE endDate ISO 8601 NO Date to get orders until EXCLUSIVE status STRING NO Status: NEW, PENDING, ACCEPTED or REJECTED limit INT NO Default 500; max 1000 Create order Register a new order POST /v2/order Note This is an idempotent POST. Any duplicate request will be completed with response of the first request within 24 hours from the first request. This behaviour in conclustion with clientOrderId prevents potential order duplicates. Permission: Order Request body: Generic { \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"some info to be stored along the order\" , \"instrument\" : \"<NAME>\" , ...instrument specific fields... } CRYPTO_BUY (fait) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_BUY.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Buy some BTC for 150.42$\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" , \"address\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"autoStart\" : false } CRYPTO_BUY (crypto) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_BUY.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Buy 0.05142111 BTC for some $\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"0.05142111\" , \"amountCurrency\" : \"BTC\" , \"address\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"autoStart\" : false } CRYPTO_SELL (fait) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_SELL.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell some BTC for 150.42$\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" , \"autoStart\" : false } CRYPTO_SELL (crypto) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_SELL.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell 0.05142111 BTC for some $\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"0.05142111\" , \"amountCurrency\" : \"BTC\" , \"autoStart\" : false } Note Instrument specific fields are described Fetch order Fetch single order by ID GET /v2/order/{{orderId}} Permission: Order or View Start processing This method make sense only for order with autoStart creating option equals to false POST /v2/order/{{orderId}}/start Permission: Order No request body Note If order already in pending state, the method will return HTTP 403 List withdrawals This method allows to get all nformation about all withdrawal operations related to an order GET /v2/order/{{orderId}}/withdrawal Note The method will return HTTP 405 Not allowed, if order's instument does not support withdrawal Permission: Order or View Create withdrawal There are several cases when crypto amount holds on order balance. This method allows to make withdrawal amount to desired crypto address POST /v2/order/{{orderId}}/withdrawal Note The method will return HTTP 405 Not allowed, if order's instument does not support withdrawal Permission: Order Request body: { \"clientOperationId\" : \"123498-WITHDRAWAL-554-12\" , \"clientOperationTag\" : \"Some info... withdrawal by user request\" , \"targetAddress\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"amount\" : \"0.0493421\" } Fetch withdrawal This method allows to get status of a withdrawal operation. GET /v2/order/{{orderId}}/withdrawal/{{operationId}} Note The method will return HTTP 405 Not allowed, if order's instument does not support withdrawal Permission: Order or View","title":"REST API"},{"location":"api/#rest-api","text":"","title":"REST API"},{"location":"api/#authentication","text":"","title":"Authentication"},{"location":"api/#generating-an-api-key","text":"Before being able to sign any requests, you must create an API key via the CryptoPay support. Upon creating a key you will have 3 pieces of information which you must remember: Key - Randomly generated and provided by CryptoPay Secret - Randomly generated and provided by CryptoPay Passphrase - Provided by you to further secure your API access. CryptoPay stores the salted hash of your passphrase for verification, but cannot recover the passphrase if you forget it.","title":"Generating an API Key"},{"location":"api/#api-key-permissions","text":"You can restrict the functionality of API keys. Before creating the key, you must choose what permissions you would like the key to have. The permissions are:","title":"API Key Permissions"},{"location":"api/#merchant-permission","text":"Allows a key manage your sub-merchants.","title":"Merchant permission"},{"location":"api/#order-permission","text":"Allows a key to enter orders, as well as retrieve order data. This includes POST /order and several GET endpoints.","title":"Order permission"},{"location":"api/#view-permission","text":"Allows a key read permissions. This includes most of GET endpoints. Please refer to documentation below to see what API key permissions are required for a specific route.","title":"View permission"},{"location":"api/#creating-a-request","text":"All REST requests must contain the following headers: CP-ACCESS-KEY The api key as a string. CP-ACCESS-SIGN The base64-encoded signature (see Signing a Message). CP-ACCESS-TIMESTAMP A timestamp for your request. CP-ACCESS-PASSPHRASE The passphrase you specified when creating the API key. All request bodies should have content type application/json and be valid JSON.","title":"Creating a Request"},{"location":"api/#signing-a-message","text":"The CP-ACCESS-SIGN header is generated by creating a sha256 HMAC using the base64-decoded secret key on the prehash string timestamp + method + requestPath + body (where + represents string concatenation) and base64-encode the output. The timestamp value is the same as the CP-ACCESS-TIMESTAMP header. The body is the request body string or omitted if there is no request body (typically for GET requests). The method should be UPPER CASE like \"GET\", \"POST\", etc. Note Do not forget to base64-decode the alphanumeric secret string (resulting in 64 bytes) before using it as the key for HMAC. Also, base64-encode the digest output before sending in the header. Bash + OpenSSL SECRET = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" #TIMESTAMP=$(date +%s) TIMESTAMP = 1573753848 METHOD = \"POST\" URLPATH = \"/v2/order\" BODY = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' WHAT = \" ${ TIMESTAMP }${ METHOD }${ URLPATH }${ BODY } \" SECRET_KEY = $( echo -n \" ${ SECRET } \" | base64 --decode | hexdump -v -e '/1 \"%02x\"' ) echo -n \" ${ WHAT } \" | openssl dgst -sha256 -mac HMAC -macopt \"hexkey: $SECRET_KEY \" | xxd -r -p | base64 // Zg0U59GORi1dXCSnRfhFeOG/PKod538ij2AnwMFC5wA = NodeJS const secret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; //const timestamp = Date.now() / 1000; const timestamp = 1573753848 ; const method = \"POST\" ; const urlPath = \"/v2/order\" ; const body = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' ; const what = timestamp + method + urlPath + body ; const secretKey = Buffer . from ( secret , \"base64\" ); const hmac = require ( \"crypto\" ). createHmac ( \"sha256\" , secretKey ); console . log ( hmac . update ( what ). digest ( \"base64\" )); // Zg0U59GORi1dXCSnRfhFeOG/PKod538ij2AnwMFC5wA= PHP <?php $secret = \"qf8qDqcEYcFQre2mgdshfdWDs29ObeW708grqMtW9I1rLY9iAl3EUn6A1HoeMSSp3XNL3qUlRJRrlo4eo7JxBw==\" ; #$timestamp = time() $timestamp = 1573753848 ; $method = \"POST\" ; $urlPath = \"/v2/order\" ; $body = '{\"merchantId\":\"p8765367\",\"feeType\":\"MERCHANT\",\"autoApprove\":true,\"address\":\"XXX--BTC-ADDRESS--XXX\",\"instrument\":\"BUY_CRYPTO\",\"amount\":\"0.0042\",\"amountCurrency\":\"BTC\",\"clientOrderId\":\"1490548887804-3111-299\",\"clientOrderTag\":\"some your information to be stored along the order\"}' ; $what = $timestamp . $method . $urlPath . $body ; $secretKey = base64_decode ( $secret ); print ( base64_encode ( hash_hmac ( \"sha256\" , $what , $secretKey , true ))); # Zg0U59GORi1dXCSnRfhFeOG/PKod538ij2AnwMFC5wA=","title":"Signing a Message"},{"location":"api/#selecting-a-timestamp","text":"The CP-ACCESS-TIMESTAMP header MUST be number of seconds since Unix Epoch in UTC. Decimal values are allowed. Your timestamp must be within 30 seconds of the api service time or your request will be considered expired and rejected. We recommend using the time endpoint to query for the API server time if you believe there many be time skew between your server and the API servers.","title":"Selecting a Timestamp"},{"location":"api/#rate-limit","text":"The API server will return a 429 response (Too Many Requests) if you have spent your allowance completely. TBD: what is limit?","title":"Rate limit"},{"location":"api/#general-rules","text":"All endpoints return either a JSON object or array. Data is returned in ascending order. Oldest first, newest last. All time and timestamp related fields are in ISO 8601 . For GET endpoints, parameters must be sent as a query string . For POST, PUT, and DELETE endpoints, the parameters are sent in the request body with content type application/json . Success request codes: 2XX Client's mistakes: 4XX Server's errors: 5XX","title":"General rules"},{"location":"api/#v2time","text":"Note This endpoint does not require authentication. GET /v2/time { \"iso\" : \"2019-11-16T10:57:37.209Z\" , \"epoch\" : 1573901857.209 } The epoch field represents decimal seconds since Unix Epoch","title":"/v2/time"},{"location":"api/#v2merchant","text":"Merchant endpoint is available for sub-merchants management. Every request must be signed using the described authentication scheme.","title":"/v2/merchant"},{"location":"api/#list-sub-merchants","text":"Returns list of sub-merchants according filter defined by parameters GET /v2/merchant TBD","title":"List sub-merchants"},{"location":"api/#create-sub-merchant","text":"TBD","title":"Create sub-merchant"},{"location":"api/#update-sub-merchants","text":"TBD","title":"Update sub-merchants"},{"location":"api/#v2order","text":"Order endpoint is available for order management. Every request must be signed using the described authentication scheme. Order statuses: NEW - Order registered and waiting for start processing PENDING - Still in progress ACCEPTED - Successfully completed REJECTED - Failure Order lifecycle: graph TD NEW --> PENDING PENDING --> PENDING PENDING --> ACCEPTED PENDING --> REJECTED","title":"/v2/order"},{"location":"api/#list-orders","text":"Returns list of orders according filter defined by parameters GET /v2/order Permission: Order or View Parameters: Agument Type Mandatory Descripton instument STRING NO Instrument name (like: CRYPTO_BUY) fromId STRING NO ID to get orders from INCLUSIVE startDate ISO 8601 NO Date to get orders from INCLUSIVE endDate ISO 8601 NO Date to get orders until EXCLUSIVE status STRING NO Status: NEW, PENDING, ACCEPTED or REJECTED limit INT NO Default 500; max 1000","title":"List orders"},{"location":"api/#create-order","text":"Register a new order POST /v2/order Note This is an idempotent POST. Any duplicate request will be completed with response of the first request within 24 hours from the first request. This behaviour in conclustion with clientOrderId prevents potential order duplicates. Permission: Order Request body: Generic { \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"some info to be stored along the order\" , \"instrument\" : \"<NAME>\" , ...instrument specific fields... } CRYPTO_BUY (fait) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_BUY.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Buy some BTC for 150.42$\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" , \"address\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"autoStart\" : false } CRYPTO_BUY (crypto) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_BUY.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Buy 0.05142111 BTC for some $\" , \"instrument\" : \"CRYPTO_BUY\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"0.05142111\" , \"amountCurrency\" : \"BTC\" , \"address\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"autoStart\" : false } CRYPTO_SELL (fait) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_SELL.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell some BTC for 150.42$\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"150.42\" , \"amountCurrency\" : \"USD\" , \"autoStart\" : false } CRYPTO_SELL (crypto) { \"$schema\" : \"https://cexiolabs.github.io/cryptopay.schemas/v2/createOrder.CRYPTO_SELL.json\" , \"clientOrderId\" : \"1490548887804-XA-1112-TU\" , \"clientOrderTag\" : \"Sell 0.05142111 BTC for some $\" , \"instrument\" : \"CRYPTO_SELL\" , \"fiatCurrency\" : \"USD\" , \"cryptoCurrency\" : \"BTC\" , \"feeModel\" : \"CUSTOM\" , \"amount\" : \"0.05142111\" , \"amountCurrency\" : \"BTC\" , \"autoStart\" : false } Note Instrument specific fields are described","title":"Create order"},{"location":"api/#fetch-order","text":"Fetch single order by ID GET /v2/order/{{orderId}} Permission: Order or View","title":"Fetch order"},{"location":"api/#start-processing","text":"This method make sense only for order with autoStart creating option equals to false POST /v2/order/{{orderId}}/start Permission: Order No request body Note If order already in pending state, the method will return HTTP 403","title":"Start processing"},{"location":"api/#list-withdrawals","text":"This method allows to get all nformation about all withdrawal operations related to an order GET /v2/order/{{orderId}}/withdrawal Note The method will return HTTP 405 Not allowed, if order's instument does not support withdrawal Permission: Order or View","title":"List withdrawals"},{"location":"api/#create-withdrawal","text":"There are several cases when crypto amount holds on order balance. This method allows to make withdrawal amount to desired crypto address POST /v2/order/{{orderId}}/withdrawal Note The method will return HTTP 405 Not allowed, if order's instument does not support withdrawal Permission: Order Request body: { \"clientOperationId\" : \"123498-WITHDRAWAL-554-12\" , \"clientOperationTag\" : \"Some info... withdrawal by user request\" , \"targetAddress\" : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" , \"amount\" : \"0.0493421\" }","title":"Create withdrawal"},{"location":"api/#fetch-withdrawal","text":"This method allows to get status of a withdrawal operation. GET /v2/order/{{orderId}}/withdrawal/{{operationId}} Note The method will return HTTP 405 Not allowed, if order's instument does not support withdrawal Permission: Order or View","title":"Fetch withdrawal"},{"location":"release-notes/","text":"Release Notes TBD","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"TBD","title":"Release Notes"},{"location":"terminology/","text":"Terminology Instrument CryptoPay's Instrument defines kind of service. An instrument decribes how to process an order. Different instrument has own set of attributes according kind field. Note Instrument defines applied commissions (may be overriden on in merchant's configuration) Each merchant has own set of allowed instument Instrument kinds Kind Description CRYPTO_BUY Buy crypo asset (convert fiat to crypto) CRYPTO_SELL Sell crypo asset (convert crypto to fiat) CRYPTO_PAYMENT Payment for goods (buy goods by crypto) CRYPTO_SELL sequenceDiagram User->>+B2C Merchant: Goes to site B2C Merchant->>+B2B Merchant: Request crypto payment B2B Merchant->>+CryptoPay: Get instruments CryptoPay-->>-B2B Merchant: Currencies, rates, etc. B2B Merchant-->>-B2C Merchant: Available instuments B2C Merchant-->>-User: Render instuments User->>+B2C Merchant: Request order B2C Merchant->>+B2B Merchant: Create order B2B Merchant->>+CryptoPay: Create order CryptoPay->>+Exchange: Get rate Exchange-->>-CryptoPay: Current rate opt Skip for dry-run mode CryptoPay->>+Wallet: Generate new address Wallet-->>-CryptoPay: New address end CryptoPay->>CryptoPay: Calulate cash flow B2B Merchant-->>B2C Merchant: Order attribures B2C Merchant-->>User: Render order details Wallet-->>CryptoPay: Confirmations: 0 (configurable) CryptoPay-->>B2B Merchant: Notify (PAID) B2B Merchant-->>B2C Merchant: Notify (DEPOSIT) Wallet-->>CryptoPay: Confirmations: 1 (configurable) CryptoPay->>+Exchange: Make exchange Exchange-->>-CryptoPay: Exchange approved B2C Merchant-->>User: Deposit processing Wallet-->>CryptoPay: Confirmations: X (configurable) CryptoPay-->>-B2B Merchant: Notify (READY TO SHIP) B2B Merchant-->>-B2C Merchant: Notify (ACCEPTED) B2C Merchant-->>-User: Deposit accepted Merhcant TBD Order TBD","title":"Terminology"},{"location":"terminology/#terminology","text":"","title":"Terminology"},{"location":"terminology/#instrument","text":"CryptoPay's Instrument defines kind of service. An instrument decribes how to process an order. Different instrument has own set of attributes according kind field. Note Instrument defines applied commissions (may be overriden on in merchant's configuration) Each merchant has own set of allowed instument","title":"Instrument"},{"location":"terminology/#instrument-kinds","text":"Kind Description CRYPTO_BUY Buy crypo asset (convert fiat to crypto) CRYPTO_SELL Sell crypo asset (convert crypto to fiat) CRYPTO_PAYMENT Payment for goods (buy goods by crypto)","title":"Instrument kinds"},{"location":"terminology/#crypto_sell","text":"sequenceDiagram User->>+B2C Merchant: Goes to site B2C Merchant->>+B2B Merchant: Request crypto payment B2B Merchant->>+CryptoPay: Get instruments CryptoPay-->>-B2B Merchant: Currencies, rates, etc. B2B Merchant-->>-B2C Merchant: Available instuments B2C Merchant-->>-User: Render instuments User->>+B2C Merchant: Request order B2C Merchant->>+B2B Merchant: Create order B2B Merchant->>+CryptoPay: Create order CryptoPay->>+Exchange: Get rate Exchange-->>-CryptoPay: Current rate opt Skip for dry-run mode CryptoPay->>+Wallet: Generate new address Wallet-->>-CryptoPay: New address end CryptoPay->>CryptoPay: Calulate cash flow B2B Merchant-->>B2C Merchant: Order attribures B2C Merchant-->>User: Render order details Wallet-->>CryptoPay: Confirmations: 0 (configurable) CryptoPay-->>B2B Merchant: Notify (PAID) B2B Merchant-->>B2C Merchant: Notify (DEPOSIT) Wallet-->>CryptoPay: Confirmations: 1 (configurable) CryptoPay->>+Exchange: Make exchange Exchange-->>-CryptoPay: Exchange approved B2C Merchant-->>User: Deposit processing Wallet-->>CryptoPay: Confirmations: X (configurable) CryptoPay-->>-B2B Merchant: Notify (READY TO SHIP) B2B Merchant-->>-B2C Merchant: Notify (ACCEPTED) B2C Merchant-->>-User: Deposit accepted","title":"CRYPTO_SELL"},{"location":"terminology/#merhcant","text":"TBD","title":"Merhcant"},{"location":"terminology/#order","text":"TBD","title":"Order"},{"location":"webhooks/","text":"Webhooks Webhooks are \"user-defined HTTP callbacks\". When that event occurs, the source app makes an HTTP request to the URI configured for the webhook. The action taken may be anything. Warning Your endpoint should ALWAYS return a valid HTTP response with HTTP status 2XX. If you do not do this then CryptoPay will think the hook failed and retry it. Security CryptoPay provides modern methods to verify that the request is legitimate. Feel free to use any (or all) of that. SSL verification If you specify a CA Certificate, it will be used to verify the SSL certificate of the webhook endpoint. Otherwise the SSL certificate of the webhook endpoint is verified based on an internal list of Certificate Authorities. Secret token If you specify a secret token , it will be sent with the hook request in the X-CP-TOKEN HTTP header. Encrypt event If you specify a encrypt password , event message will be encrypted. Signing event To sign events CryptoPay uses same algorithm as for incoming request, except the header CP-ACCESS-PASSPHRASE is omitted. Events Order execution TBD Operation execution TBD","title":"Webhooks"},{"location":"webhooks/#webhooks","text":"Webhooks are \"user-defined HTTP callbacks\". When that event occurs, the source app makes an HTTP request to the URI configured for the webhook. The action taken may be anything. Warning Your endpoint should ALWAYS return a valid HTTP response with HTTP status 2XX. If you do not do this then CryptoPay will think the hook failed and retry it.","title":"Webhooks"},{"location":"webhooks/#security","text":"CryptoPay provides modern methods to verify that the request is legitimate. Feel free to use any (or all) of that.","title":"Security"},{"location":"webhooks/#ssl-verification","text":"If you specify a CA Certificate, it will be used to verify the SSL certificate of the webhook endpoint. Otherwise the SSL certificate of the webhook endpoint is verified based on an internal list of Certificate Authorities.","title":"SSL verification"},{"location":"webhooks/#secret-token","text":"If you specify a secret token , it will be sent with the hook request in the X-CP-TOKEN HTTP header.","title":"Secret token"},{"location":"webhooks/#encrypt-event","text":"If you specify a encrypt password , event message will be encrypted.","title":"Encrypt event"},{"location":"webhooks/#signing-event","text":"To sign events CryptoPay uses same algorithm as for incoming request, except the header CP-ACCESS-PASSPHRASE is omitted.","title":"Signing event"},{"location":"webhooks/#events","text":"","title":"Events"},{"location":"webhooks/#order-execution","text":"TBD","title":"Order execution"},{"location":"webhooks/#operation-execution","text":"TBD","title":"Operation execution"},{"location":"websocket-api/","text":"WebSocket API Overview TBD TBD TBD TBD TBD TBD","title":"WebSocket API"},{"location":"websocket-api/#websocket-api","text":"","title":"WebSocket API"},{"location":"websocket-api/#overview","text":"TBD","title":"Overview"},{"location":"websocket-api/#tbd","text":"","title":"TBD"},{"location":"websocket-api/#tbd_1","text":"","title":"TBD"},{"location":"websocket-api/#tbd_2","text":"","title":"TBD"},{"location":"websocket-api/#tbd_3","text":"TBD","title":"TBD"}]}